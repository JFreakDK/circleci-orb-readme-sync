# ReadMe Synchronization Orb for CircleCI

This is a prototype CircleCI orb that wraps a subset [ReadMe CLI](https://github.com/readmeio/rdme), allowing you to synchronize documents from your CircleCI pipeline.

## Available Jobs

* `readme-sync/sync-docs`
* `readme-sync/sync-spec`

## Configuration

### Project Token

All jobs require a ReadMe API key. This is passed into each sync job, preferably as an environment variable:

```
workflows:
  version: 2
    deploy_docs:
      jobs:
        - sync-docs:
            readme-api-key: README_API_KEY
```

## Adding a new document

### Get the ReadMe category ID

If you are adding a new document to a new category on ReadMe, you will need to retrieve the new category ID. The simplest way to 
do this would be to use their [Category API](https://docs.readme.com/developers/reference/categories). If the category already exists
and there are existing files for that category, simply copy the category ID from the metadata header, as described [below](#add-the-proper-document-metadata).

### Add the proper document metadata

ReadMe's Markdown flavor uses a metadata header at the top of each document that contains info such as the title, category ID,
parent document ID, and so forth. These fields map to the corresponding REST API parameters in the [destructive API endpoints](https://docs.readme.com/developers/reference/docs#updatedoc):


```
---
title: Your Document Title
category: some-category-id
parentDoc: your-parent-doc <-- optional
---
```

### Parent-child relationships

This orb currently uses the following folder structure to represent a parent-child relationship:

```
my-docs/
   parent-doc.md
   parent-doc/
      child-doc.md
```

This allows for the parent to be synced first, and then have its ID retrieved to be used to create the parent-child connection
with the child document subfolder.

## Working with API Specs

A job is available to sync an API spec: `sync-spec`.

### Required parmeters

#### API ID

The ID for an API can be retrieved directly from the `API Reference` section of the ReadMe dashboard, or via the [category API](https://docs.readme.com/developers/reference/categories) (an API is actually a category under the hood).

Syncing an API spec requires an API ID. This can either be passed in as a parameter to the job, or you can create
an `id` file that lives alongside the spec, containing only the ID of the API.

```
my-api/
   my-api.yaml
   id
```

### Folder Structure

Similar to the [parent-child relationship](#parent-child-relationships) for docs, accompanying resource docs for an API can live alongside the API spec:

```
my-api/
   my-api.yaml
   my-resource.md # The root resource doc
   my-resource/
    get-resource.md # A doc for the resource method
    add-resource.md
   another-resource.md
   another-resource/
    update-resource.md
    delete-resource.md
```

__Note:__ This folder structure isn't necessarily required, but mirrors the way that documents are organized on ReadMe.

__Note:__ These docs should be named to match the correct slug of the API resource in ReadMe. The way these slugs are determined is covered in the next sections.


### API Naming Conventions

The following is a brief summary that paraphrases much ReadMe's [own documentation](https://docs.readme.com/guides/docs/openapi).

#### API Page Titles

ReadMe will use the first tag under the `tags` block as the title for root resource pages.

```
/devices:
  post:
    tags:
      - devices
    summary: adds a device
    description: Adds a device to the system
    operationId: addDevice
```

If no tags are present, the url of the resource is used for the page title.

#### API Subpage Titles

Subpages for resources ("get devices", "add device", etc.) get their titles from their `summary` value. Otherwise, the URL is used.

#### API Resource Slugs

The slugs for API resource docs are automatically generated by ReadMe using the two methods described below.

##### OpenAPI `operationId`

For a given OpenAPI resource, ReadMe will use the resource's `operationId`, if present, to generate the slug of a page. The value is then lowercased. For example, in the following template:

```
/devices:
  post:
    tags:
      - devices
    summary: adds a device
    description: Adds a device to the system
    operationId: addDevice
```

The generated slug for the API resource would be `adddevice`. The file would be named `adddevice.md`.

If there is no `operationId` present, ReadMe will use their own algorithm to create the page slug for you. Given a resource:

```
...
/devices/{model}/{serial_number}/tests:
   get:
     tags:
       - devices
```

ReadMe will take the root URL (in this case, `devices`), lowercase it, remove alphanumeric characters, and concatenate it to the HTTP method, like so:

```get_devices```

Additional path items are added to the end, separated by dashes:

```get_devices-model-serial-number-tests```

This would require a filename of `get_devices-model-serial-number-tests.md`. This can quickly get out of hand, so it is preferable that you specify an `operationId` to keep things simple. The folder structure for a nested relationship would stil stay relatively flat:

```
device-api/
   device-api.yaml
   devices.md # The root resource doc
   devices/
    adddevice.md
    get_devices-model-serial-number-tests.md
```

Technically, these documents could be even flatter since a child document's slug and category ID tie it to its API after it is initially created.

Read more about ReadMe's OpenAPI name generation [here](https://docs.readme.com/guides/docs/openapi-categories-pages-subpages).

#### Metadata

Every resoure doc should also contain the proper
metadata header as described [here](#add-the-proper-document-metadata). The category ID for the API can be had via the [category API](https://docs.readme.com/developers/reference/categories).

## Deleting documents

This orb does not currently support deleting documents, since the ReadMe CLI does not also support it. However, docs can be deleted via either the ReadMe dashboard or their REST API.

## Contributing

Feel free to file an issue or make any pull requests! We will get back to you as soon as possible.